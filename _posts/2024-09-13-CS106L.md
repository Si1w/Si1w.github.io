---
title: CS106L Stanford University
date: 2024-09-13 14:06:01
tags: C++
categories: Computer Science
---
# Brief Intro to C++ feature

## Design Philosophy of C++

- <font color=orange>**Only add features if they solve an actual problem**</font>
- <font color=orange>**Programmers should be free to choose their own style**</font>
- Compartmentalization is key
- Allow the programmer full control if they want it
- Don’t sacrifice performance except as a last resort
- Enforce safety at compile time whenever possible
- Only add features if they solve an actual problem
- Programmers should be free to choose their own style
- <font color=orange>**Compartmentalization is key**</font>
- <font color=orange>**Allow the programmer full control if they want it**</font>
- Don’t sacrifice performance except as a last resort
- Enforce safety at compile time whenever possible
- Only add features if they solve an actual problem
- Programmers should be free to choose their own style
- Compartmentalization is key
- Allow the programmer full control if they want it
- <font color=orange>**Don’t sacrifice performance except as a last resort**</font>
- <font color=orange>**Enforce safety at compile time whenever possible**</font>

<!--more-->

## Basic syntax

- Semicolons at EOL
- Primitive types (ints, doubles etc)
- Basic grammar rules

```cpp
// To import additional functionality we use #include
#include <iostream>

/* 
Functions declarations need the 'type of the return', the 'name of the
function' and 'any parameters' (inside the parentheses).
*/
int main() { 
		// All lines/statements end in a semicolon
		std::cout << "Hello, world!" << std::endl;
		return 0;
		// The code of a function lives inside a block marked by '{}'
}
```

## The STL

- Tons of general functionality
- Built in classes like maps, sets, vectors
- Accessed through the namespace std::
- Extremely powerful and well-maintained

### Namespaces

- MANY things are in the `std::`namespace
    - e.g. `std::cout`, `std::cin`, `std::lower_bound`
- A good style will contain `std::` at the most of time

### STL Naming Conventions

**STL** = Standard Template Library
- It contains TONS of functionality (algorithms, containers, functions, iterators)

`STD::` = the STL namespace

So to access elements from the **STL** use `std::` !

## Fundamental Types

```cpp
int val = 5; // 32 bits (usually)
char ch = 'F'; // 8 bits (usually)
float decimalVal1 = 5.0; // 32 bits (usually)
double decimalVal2 = 5.0; // 64 bits (usually)
bool bVal = true; // 1 bits
std::string str = "Haven";

std::string a = “test”; 
double b = 3.2 * 5 - 1; 
int c = 5 / 2;
int d(int foo) { return foo / 2; }
double e(double foo) { return foo / 2; } 
int f(double foo) { return int(foo / 2); }
void g(double c) {
    std::cout << c << std::endl;
}
```

Here, 

**C++ is a statically typed language!**

**Statically typed:** everything with a name (variables, functions, etc) is given a type before runtime.

A language like Python is **dynamically typed:** everything with a name (variables, functions, etc) is given a type at runtime based on the thing’s **current value**

## Compiled v.s. Interpreted

Spot the difference: When is **source code translated**?

- **Source code:** Original code, usually typed by a human into a computer (like C++ or Python)
- **Translated:** Converting source code into something a computer can understand (i.e. machine code)

### Dynamically typed, interpreted

- Types are checked on the fly, during the execution, line by lien
- Example: Python

```py
a = 3
b = "test"
def func(c):
    # do something
```

### Statically typed, compiled

- Types before program runs during compilation
- Example: C++

```cpp
int a = 3;
std::string b = "test";
char func(std::string c) { 
    // do something
}
```

## The problem with types
Strongly and statically typed languages are great, but there are a few downsides:

- <font color=skyblue>it can be a pain to know what the type of a variable is</font>
    - <u>auto:</u> a keyword used in lieu of type when declaring a variable that tells the compiler to **deduce the type**.
- any given function can only have exactly one return type
- C++ primitives (and even the types in the STL) can be limited

## Struct

A **struct** is a group of nammed variables, each with their own type, that allows programmers to **bundle different types** together!

```cpp
struct Student {
    std::string name; // these are called fields
    std::string state; // separate these by semicolons
    int age;
};

Student s;
s.name = "Haven";
s.state = "AR";
s.age = 22; //use . to access fields

void printStudentInfo(Student s) {
    cout << s.name << " from " << s.state; 
    cout << " (" << s.age ")" << endl;
}

// or

Student randomStudentFrom(std::string state) {
    Student s;
    s.name = "Haven"; // random = always Haven
    s.state = state;
    s.age = std::randint(0, 100);
    return s
}

Student foundStudent = randomStudentFrom("AR");
cout << foundStudent.name << endl; //Haven

// Abbreviate
Student s
s.name = "Haven";
s.state = "AR";
s.age = 22;

Student s = {"Haven", "AR", 22};
```

<u>**std::pair:**</u> An STL built-in struct with **two fields** of **any type**

- **std::pair** is a template: You specify the types of the fields inside <> for each pair object you make
- The fields in **std::pair** are named **first** and **second**

```cpp
std::pair<int, string> numSuffix = {1, "st"};
cout << numSuffix.first << numSuffix.second; // print 1st

// Basically the struct looks like this
struct pair {
    fill_in_type first;
    fill_in_type second;
};

std::pair<bool, Student> lookupStudent(string name) {
    Student blank;
    if (notFound(name)) return std::make_pair(false, blank);
    Student result = getStudentWithName(name);
    return std::make_pair(true, result);
};
auto output = lookupStudent("Julie");
```

# Initialization + References, Streams

## Initialization

```cpp
#include <iostream>

int main() {
    int criticalSystemValue(42.5); // Direct initialization with a floating-point value
    std::cout << "Critical system value: " << criticalSystemValue << std::endl;
}
```
<u>C++ doesn't care in this case</u>, it doesn't type check with direct initialization

```cpp
#include <iostream>

int main() {
    // NOTICE: brackets
    int numOne{12};
    int numOne{12};
    std::cout << "numOne is" << numOne << std::endl;
    std::cout << "numTwo is" << numTwo << std::endl;
}
```

With uniform initialization C++ <u>**does**</u> care about types

### Uniform initialization (C++11)

Uniform initialization is awesome because:

1. It's <font color=yellow>**safe!**</font> It doesn't allow for narrowing conversions-which can lead to unexpected behaviour(or critical system failure)

2. It's <font color=yellow>**ubiquitous**</font> it works for all types like vectors, map, and custom classes, among other things!

### Structured Binding

- A useful way to initialize some variables from data structures with fixed sizes at compile time

- Ability to access multiple values returned by a function

```cpp
#include <iostream>
#include <tuple>
#include <string>

std::tuple<std::string, std::string, std::string> getClassInfo(){
    std::string className = "CS106L";
    std::string buildingName = "Turing Auditorium";
    std::string language = "C++";
    return {className, buildingName, language};
}

int main() {
    auto [className, buildingName, language] = getClassInfo();
    std::cout << "Come to " << buildingName << " and join us for" << className << " to learn" << language << "!" << std::endl;

    return 0;
}
```

## Reference

"Declares a name variable as a reference"

tldr: a reference is an alias to an already-existing thing

Use an ampersand(&)

```cpp
int num = 5
int& ref = num;
ref = 10 // Assigning a new value through the reference
std::cout << num << std:endl; // Output 10
```
<font color=yellow>ref</font> is a variable of type int&, that is an <u>alias</u> to num

### Pass by reference

```cpp
#include <iostream>
#include <math.h>

void squareN(int& n) {
    n = std::pow(n, 2); // Calculates n to the power of 2
}

int main() {
    int num = 2;
    squareN(num);
    std::cout << num << std::endl; // Output 4
}
```

Passing in a variable by <u>*reference*</u> into a function just means "<font color=red>Hey take in the actual piece of memory, don't make a copy!</font>"

Passing in a variable by <u>*value*</u> into a function just means "<font color=red>Hey make a copy, don't take in the actual variable!</font>"

**A reference** refers to the same memory as its associated variable!

```cpp
#include <iostream>
#include <math.h>
#include <vector>

void shift(std::vector<std::pair<int, int>> &nums) {
    for (auto& [num1, num2]: nums) {
        num1++;
        num2++;
    }
}
```
### L-values v.s. R-values

An <font color = blue>l-value</font> can be to the left <u>**or**</u> the right of an equal sign!
```cpp
x = 344
int y = x // x is a l-value
```
An <font color = red>r-value</font> can be <u>***only***</u> to the right of an equal sign!
```cpp
int y = 21 // 21 is a r-value
```

#### Is `int& num` an l-value?
```cpp
#include <iostream>
#include <math.h>

void squareN(int& n) {
    n = std::pow(n, 2); // Calculates n to the power of 2
}
```
`num` is an l-value

1. Remember what we said about r-values are temporary. Notice that `num` is being passed in by reference!

2. We <u>***cannot***</u> pass in an r-value by reference because they are temporary!
### Const

A qualifier for objects that declares they cannot be modified

```cpp
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec{1, 2, 3}; // a normal vector
    const std::vector<int> const_vec{1, 2, 3}; // a const vector
    std::vector<int>& ref_vec{ vec }; // a reference to 'vec'
    const std::vector<int>& const_ref{ vec }; // a const reference

    vec.push_back(3); // this is OKAY!
    const_vec.push_back(3); // NO this is const
    ref_vec.push_back(3); // this is ok, just a reference
    const_ref.push_back(3); // this is const, compile error

    return 0;
}
```
Also, we <u>**cannot**</u> declare a non-const reference to a const variable

### Appendix

- C++ is a compiled language

- There are computer programs called <u>compile</u>

- A few popular compilers include clang and g++

- <u>***Here is how to compile a program using g++***</u>

    - **g++:** This is the compiler command

    - **-std=c++:** This specifies the c++ version you want to compile in

    - **main.cpp:** This is the source file

    - **-o:** This means that you're going to give a specific name to your executable

## Streams

A stream is a general <u>**input/output(IO)**</u> <font color=yellow>abstraction</font> for C++

Abstractions often provide a consistent <u>***interface***</u>, and in the case of <font color=orange>streams</font> the interface is for <u>reading</u> and <u>writing</u> data

`cout` and `cin` are known as the standard `iostream`

- `cerr` and `clog`

`cerr`: used to ouput errors (unbuffered)

`clog`: used for non-critical event logging (buffered)

Streams allow for a **universal** way of **dealing with external data**

### Output streams

```cpp
std::cout << "Hello, World" << std::endl;
```

`std::cout` The stream is an <font color=blue>instance</font> of `std::ostream` which represents the standard output stream!

- a way to write data to a destination

    - Are inherited from `std::ostream`
    - ex. writing out something to the console(`std::cout`)
    - primary operator: `<<`(called the insertion operator)

Character in output streams are stored in an intermediary buffer before being flushed to the destination

`std::cout` stream is **line-buffered**

contents in buffer not shown on external source until an explicit flush occurs

`std::endl` tells the cout stream to end the line, <u>**also**</u> tells the stream to <font color=purple>flush</font>

When a stream is flushed **the intermediate buffer is cleared!**

#### Output File Streams

- Output file streams have a type: `std::ofstream`

- a way to write data to a file

    - use the `<<` insertion operator to <u>***send***</u> to the file

    - methods:

        - `is_open()`

        - `open()`

        - `close()`

        - `fail()`

```cpp
int main() {
    // associating file on construction
    std::ofstream ofs("hello.txt")
    if (ofs.is_open()) {
        ofs << "Hello CS106L" << '\n';
    }
    ofs.close();
    ofs << "this will not get written";

    ofs.open("hello.txt");
    ofs << "this will though! It's open again";

    return 0;
}
```

### Input streams

```cpp
void verifyPi() {
    double pi;
    std::cin >> pi;
    // verify the value of pi!
    std::cout << pi/2 << '\n';
}
```

The `std::cin` stream is an <font color=blue>instance</font> of `std::istream` which represents the standard input stream

- a way to read data from a source

    - Are inherited from `std::istream`
    - ex. reading in something from the console(`std::cin`)
    - primary operator: `>>`(called the extraction operator)

```cpp
int main() {
    double pi;
    double tao; 
    std::string name;
    std::cin >> pi;
    std::getline(std::cin, name);
    std::getline(std::cin, name);
    std::cin >> tao;
    std::cout << "my name is: " << name << " tao is: " << tao << " pi is: " << pi << '\n';
    return 0;
}
```

`cin`: 3.14\nSteven Wu\n6.28\n

Hint: You actually <u>***shouldn't***</u> use `getline()` and `std::cin` together because of the difference in how they parse data

#### Input File Streams
```cpp
int intputFileStreamExample() {
    std::ifstream ifs("append.txt")
    if (ifs.is_open()) {
        std::string line;
        std::getline(ifs, line);
        std::cout << "Read from the file: " << line << '\n';
    }
    if (ifs.is_open()) {
        std::string lineTwo;
        std::getline(ifs, lineTwo);
        std::cout << "Read from the file " << lineTwo << '\n'
    }
    return 0;
}
```

Input and output streams on the same source/destination type are complimentary each other!

### stringstreams

`std::stream` is a way to treat strings as streams, which is useful for use-cases that deals with mixing data type

```cpp
int main() {
    // partial Bjarne Quote
    std::string initial_quote = "Bjarne Stroustrup C makes it easy to shoot yourself in the foot";

    // create a stringstream
    std::stringstream ss(initial_quote);

    // data destinations
    std::string first;
    std::string last;
    std::string language, extracted_quote;

    ss >> first >> last >> language >> extracted_quote;
    std::getline(ss, extracted_quote);
    std::cout << first << " " << last << " said this: " << language << " " << extracted_quote << std:endl;
}
```

First: Bjarne

Last: Stoustrup

Language: C

extracted_quote: makes it easy to shoot yourself in the foot

- `getline()` reads an input stream, `is`, up until the `delim` char and stores it in some buffer, `str`

- The `delim` char is by default `'\n'`

- `getline()` <font color=red>***consumes***</font> the delim character!

# Containers, Iterators, Pointers

## Container

**Container:** An object that allows us to collect other objects together and interact with them in some way

- **Organization:** Related data can be packaged together

- **Standardization:** Common features are expected and implemented

- **Abstraction:** Complex ideas made easier to utilize by clients

## Container in the STL

### Standardization

Typically, container export some standard, basic functionality.

- Allow you to store multiple objects 

- Allow access to the collection through some way

    - Maybe allow iteration through all of the objects

- May allow editing/deletion

### Containers

- An **array** is the primitive form of a vector

    - Fixed size in a strict sequence

- A **deque** is a **d**ouble **e**nded **que**ue

- A **list** is a doubly linked list

    - Can loop through in either direction

#### Aside:

- **List:** A collection of items that might be ordered. For example, a mailing list that might be ordered by alphabetical order of sendee, or an airline waitlist that might be ordered chronologically.

- **Array:** A fixed number of data items that are stored contiguously and that are accessible by index.

- **Stack:** This is a list of items where items are only added (with an operation called push) or deleted (with an operation called pop) from one end of the list. Therefore the last item added to the list is the first item removed. So a stack is a “last-in first-out” data structure. This can be useful in many algorithms such as for simple arithmetic.

- **Queue:** Like stacks but items are added at one end and removed from the other end (First-in first-out).

### Types of containers

Sequence:

- Containers that can be accessed sequentially

- Anything with an inherent order goes here

Associative:

- Containers that don't necessarily have a sequential order

- More easily searched

- Maps and sets go here

**NEW in C++23:** `flat_map` and `flat_set` are the container adaptors of sequence containers that are faster than the default in most use cases

### Sequence Containers

#### Vector implementation

At a high level, a vector is an **ordered** collection of elements of the **same type** that can <font color=orange>grow and shrink</font> in size

- **_size** = number of elements in the vector

- **_capacity** = space allocated for elements

#### Sequence Containers: Summary

- Sequence containers are for when you need to enforce some order on your information

- Can usually use an `std::vector` for most anything

- If you need particularly fast inserts in the front, consider an `std::deque`

- For joining/working with multiple lists, consider an `std::list`(very rarely)

### Associative Containers

#### Map implementation

Maps are implemented with pairs(`std::pair<const key, value>`)

- Note the `const` Keys must be immutable

- Index into the map (`myMap[key]`) searches through the underlying collection of pairs first attribute for the key and will return its second attribute

#### Unordered maps/sets

- **Ordered** maps/sets require a **comparison operator** to be defined

- **Unordered** maps/sets require a **hash function** to tbe defined

Unordered maps/sets are usually faster than ordered ones!

#### Aside: Hashing

Hash functions essentially provides a mapping from some complex object to a number

- The act of calculating one such mapping is knonwn as hashing

We can hash most anything if you can figure out a good hash function

- Strings

- Structs

- Objects

- Even other numbers

#### Choosing a hash function

- Be fast to compute

- Always map the same input to the same output

- Avoid collisions wherever possible

```cpp
hashFn1(string x) = x.size() // BAD! Collisiions!
hashFn2(int x) = std::rand() + x / 10 // BAD! Random!
hashFn3(string x) = x % 5 // GOOD!
```

#### Choosing associative containers

- Unordered container are **faster**, but can be difficult to get to work with nested containers/collections

- If using **complicated data types**/unfamiliar with has functions, use an ordered container

## Container Adaptors

Container adaptors are "wrappers" to existing containers

- Wrappers **modify the interface** to sequence containers and change what the client is allowed to do/how they can interact with the container`

**queue**s are implemented as ***containers adaptors***, which are classes that use an encapsulated object of a specific container class as its ***underlying container***, providing a specific set of member functions to access its elements. Elements are ***pushes*** into the "**back**" of the specific container and ***popped*** from its "**front**"

- `std::stack` Last in, First Out

- `std::queue` First in, First Out

## Iterators

### Loop

`for (initialization; termination condition; increment) {}`

### Introducing Iterators

Containers all implement something called an iterator to do this

- Iterators let you access **all** data in containers programmatically

- An iterator has a certain **order**; it "knows" what element will come next

    - Not necessarily the same each time you iterate

**Think of your container as a file cabinet**

An iterator lets you go through the files one at time

- You can see where the front and back of your drawer are.

- You can move your finger from one to the next, because you kept your place.

- You can take out any file you've your hand on, and read/write whatever you'd like in it

- You can compare the relative location of any two files just by looking at where they are in the cabinet

### In the STL

All containers implement iterators, but they're not all the same

- Each container has its own iterator, which can have different behavior

- All iterators implement a few shared operations:

    - Initializing ---> `iter = s.begin();`

    - Incrementing ---> `++iter;`

    - Dereferencing ---> `*iter;`

    - Comparing ---> `iter != s.end()`

    - Copying ---> `new_iter = iter;`

### Iterator categories

**Forward** iterators are the minumum level of functionality for standard containers

- **Input** iterators can appear on the RHS of an `=` operator(read only)

    `auto elem = *it;`

- **Output** iterators can appear on the LHS of an `=` operator (write only)

    `*elem = value;`

**Bidirectional** iterators can go forward as well as backward

- **`--iter;`**

- Still has the same functionality of forward iterators

**Random-access** iterators allow you to directly access values without visiting all elements sequentially

- **`iter += 5`**

- Think of vectors; `vec[1]` or `vec[17]`

- Be careful not to go out of bounds!

| Container | Type of Iterator |
| --- | --- |
| Vector | Random-Access |
| Deque | Random-Access |
| List | Bidirectional |
| Map | Bidirectional |
| Set | Bidirectional |
| Stack | No Iterator |
| Queue | No Iterator |
| Priority Queue | No Iterator |

## Pointers

Iterators are a particular type of pointer

- Iterators "point" at particular elements in a **container**

- Pointers can "point" **any objects** in your code

### Memory and You

Variables created in your code take up space on your computer

They live in memory at specific addresses

Pointers reference those memory addresses and not the object themselves

### Dereferencing

Pointers are marked by the asterisk(*) next to the type of the object they're pointing at when they're declared

The address of a variable can be accessed by using & before its name, same as when passing by reference

If you want to access the data stored at a pointer's address, dereference it using an asterisk again

`std::cout >> *ptr >> std::endl;`

#### Recap

- a: Represents the value of the variable a.

- &a: Represents the memory address of the variable a.

- *p: Represents the value stored at the memory address pointed to by the pointer p.

### If the object has member variables

If we need to access apointer's object's member variables, instead of dereferencing (*ptr) and then accessing (.var), there's a shorthand

`*ptr.var == ptr->var`

#### Difference

- Iterators are a type of pointer

- Iterators have to point to elements in a container, but pointers can point to any object

    - All objects stored inside the big container known as **memory**

- Can access memory addresses with `&` and the data at an address/pointer using `*`

# Classes, Template Classes, Const

## Classes

### Why classess

- One of the premises of the entire C++ language was the lack of object-oriented-programming (OOP) in C

- Classes are user-defined typres that allow a user to ***<u>encapsulate</u>***
data and functionality using member variables and member functions

### OOP

- Object-oriented-programming is centred around **objects**

- Focuses on design and implementation of classes

- Classes are the **user-defined** types that can be declared as an object

### Comparing `struct` and `class`

classes containing a sequence of objects of various types, a set of functions for manipulating these objects, and a set of restrictions on the access of these objects and function;

structures which are classes without access restrictions

#### Recall the `struct`

```cpp
struct Student {
    std::string name; // these are fields
    std::string state;
    int age;
};
Student s;
s.name = "Steven";
s.state = "CA";
s.age = 20
s.age = -2345 // ???
```

All these fields are public i.e. can be changed by the user

Because of this, we can't enforce certain behaviors in structs, like avoiding a negative age

### Header File (**.h**) v.s. Source Files (**.cpp**)

#### Header File

- Are used to define the interface of a class

- Typically contain:

    - Function prototypes

    - Variable declarations

    - Class definitions

    - Type definitions

    - Macros and constants

    - Template definitions

- **Define Functions**

- **Interface**

#### Source File

- Are used to define the implementations of the functions and classes declared in the header file

- Typically containL

    - Function implementations

    - Executable code

- **Implement logic**

- **Logic**

### Class design

1. A constructor

2. Private member functions/variables

3. Public member functions(interface for a user)

4. Destructor

### Constructor

The constructor initializes the state of newly created objects

```h
#include <string>
class Student {
private:
    std::string name;
    std::string state;
    int age;

public:
    Student(std::string name, std::string state, int age);
    std::string getName();
    std::string getState();
    int getAge();
}
```

```cpp
#include "Student.h"
#include <string>

std::string Student::getName() {
    return this->name;
}

std::string Student::getState() {
    return this->state;
}

int Student::getAge() {
    return this->age;
}

void Student::setName(std::string name) {
    this->name = name;
}

void Student::setState(std::string state) {
    this->state = state;
}

void Student::setAge(int age) {
    if (age >= 0){
        this->age = age;
    }
}

//default constructor
Student::Student() {
    name = "John Appleseed";
    state = "CA"
    age = 18;
}

// parameterized constructor
Student::Student(std::string name, std::string state, int age) {
    // Use `this` keyword to disambiguate which 'name' referring to
    this->name = name;
    this->state = state;
    this->age = age;
}

Student::~Student() {
    // free/deallocate any data here
    delete [] my_array; // for illustration
}

// The destructor is not explicitly called, it is automatically called when an object goes out of scope
```

#### some cool class stuff

**Type aliasing -** allows you to create synonymous identifiers for types

```h
class Student {
Private:
    // an example of type aliasing
    using String = std::string
    String name;
    String state;
    int age;

public:
    Student(String name, String state, int age);
    String getName();
    String getState();
    int getAge();
}
```
## Container adapters

**ALL** containers in the STL are ***<u>classes</u>***

`template <class T, class Container = deque<T> > class queue;`

## Inheritance

- **Polymorphism:** Different objects might need to have the same interface

- **Extensibility:** Inheritance allows you to extend a class by creating a subclass with specific properties

```h
class Shape {
public:
    // This is a virtual function, meaning that it is instantiated in the base class but overwritten in the subclass
    virtual double area() const = 0;
};

// Here we declare the **Circle** class which inherits from the **Shape** class
class Circle : public Shape {
public:
    // constructor
    // Here we have our constructor using list initialization construction
    Circle(double radius): _radius(radius) {};
    double area() const {
        // Here we are overwriting the base class function **area()** for a circle
        return 3.14 *_radius *_radius;
    }

private:
    // Another pro of inheritance is the encapsulation of class variables
    double _radius
};
```

### Subclass v.s. Container Adapter

- **Subclasses** inherit from base class functionality

- **Container adapters** provide the interface for several classes and act as a **<u>template parameter</u>**

## Template classes

<font color=pink>**Template Class:**</font> A class that is parametrized over some number of types; it is comprised of member variables of a general type/types

```hh
template <typename T>
class Container {
public:
    Container (T val);
    T getValue();

private:
    T value;
};
```

This is a <font color=pink>**template declaration**</font> and allows us to create template classes

`template <typename T, typename U>`

This is a <font color=pink>**template declaration**</font> list which can have various template parameters representing different types

When doing our implementation for our template classes, we need to create <font color=pink>template functions</font>

C++ wants use to specify out template parameters in our namespace because, based on the parameters our class may behave differently

**class** and **type name** are interchangeable in the template declaration list

## Const correctness

```cpp
std::string stringify(const Student& s) {
    return s.getName() + " is " + std::to_string(s.getAge()) + " years old. "
}
```

- By passing in `s` as `const` we made a promise to not modify s

- The compiler doesn't know whether or not `getName()` and `getAge()` modify `s`

- Remember, member functions can access and modify member variables

so we need

```h
class Student {
public:
    Student(String name, String state, int age);
    void setName(String name);
    String getName() const;
    String getState();
    int getAge() const;
}
```

```cpp
std::string Student::getName() const {
    return this->name;
}

std::string Student::getAge() const {
    return this->age;
}
```

**Definition:** Objects that are `const` can only interact with the const-interface

The const interface is simply the functions that are const/do not modify the object/instance of the class

### IntArray

```h
class IntArray {
Private:
    int* _array
    size_t _size
}

Public:
    IntArray(size_t size);
    ~IntArray();
    int& at(size_t index);
    int size()
```

```cpp
IntArray::IntArray(size_t size) : _size(size), _array(new int[size]);

IntArray::~IntArray() {
    delete [] _array;
}

int& at(size_t index) {
    return _array[index];
}
// const onjects must use the const interface
// Our .at() function is not const

int size() {
    return this->size;
}

// so we have to write
int& findItem(int value) {
    for (auto& elem: arr) {
        if (elem == value) return elem;
    }

    throw std::out_of_range("value not found")
}
const int& findItem(int value) const {
    for (auto& elem: arr) {
        if (elem == value) return elem;
    }

    throw std::out_of_range("value not found")
}
```

```cpp
#include "IntArray.h"
#include <iostream>

static void printElement(const IntArray& arr, size_t index) {
    std::cout << arr.at(index) << std::endl;
}

int main() {
    IntArray arr = IntArray(10);
    int& secondVal = arr.at(1);
    secondVal = 19;
    printElement(arr, 1);
    return 0;
}
```

### A slight(but useful) aside

**Casting:** The process of converting types, there are many ways to do this

**const_cast:**

- `const_cast<target-type>`

- We can use `const_cast` to cast away `const`-ness

```cpp
const int& findItem(int value) const {
    return const_cast<IntArray&>(*this).findItem(value)
}
```

1. Cast so that is is pointing to a non-const object

2. Call the non-const version of the function

3. Then cast the non-const return from the function call to a const version

# Template Functions, Functions, Lambdas

## Template Functions

<font color=orange><u>**Template Function:**</u></font> Functions whose functionality can be adapted to more than one type or class without repeating the entire code for each type

```cpp
template <typename Type>
Type myMin(Type a, Type b) {
    return a < b ? a : b;
}
```

`template` indicating this function is a template

`<typename >` specifies that tyep is generic 

`< Type>` list of your template variables

If a type isn't specified, it will default to `int` if possible

### Aside: Constraints and Concepts

We can limit the acceptable types in:

- template classes

- template functions

- non-template member functions of a template class

These limits or requirements on are called **constraints**

A named set of constraints is a **concept**

Constraints can be simple:

```cpp
template<typename T>
concept Addable = requires (T a, T b) {
    a + b;
}; // "the expression a + b is a valied expression that will compile"

template<tyepname T> requires Addable<T> // requires-clause
T add(T a, T b) { return a + b; }

template<Addable T>
T add(T a, T b) { return a + b; }
// This shorthand also works
```

### Calling template functions

```cpp
template <typename Type>
Type myMin(Type a, Type b) {
    return a < b ? a : b;
}

// int main() {} will be omitted from future examples
// we'll instead show the code that'd go inside it
cout << myMin<int>(3, 4) << endl;
```

`<int>` Just like in template classes

or we can also **implicityly** leave it for the compiler to deduce

```cpp
template <typename T, typename U>
auto smarterMyMin(T a, U b) {
    return a < b ? a : b;
}

cout << smarterMyMin(3.2, 4) << endl;
```

### Behind the Instantiation Scenes

Remember: like in template classes, **template functions are not compiled until used**

- For each instantiation with different parameters, the compiler generates a new specific version of your template

- After compilation, it will look like you wrote each version yourself

## Template metaprogramming

### Templates can be used for efficiency

Normally, code runs during **runtime**

With template metaprogramming, code runs **onece** during **compile time!**

```cpp
template<unsigned n>
struct Factorial {
    enum { value = n * Factorial<n-1>::value };
};

template<>
struct Factorial<0> {
    enum { value = 1};
};

std::cout << Factorial<10>::value << std::endl;
```

### Aside: `constexpr`

There are other ways in C++ to make code run during compile time

The `constexpr` keyword specifies a constant expression

- Constant expressions must be immediately initialized and will run at compile time

- Passed arguments to constant expressions should be const/constant expressions as well.

Variables can also be declared as `constexpr`

**constexpr** is an institutionalization of template metaprogramming and is often more readable

```cpp
constexpr double fib(int n) {
    if (n == 1) return 1;
    return fib(n-1) * n;
}

int main() {
    const long long bigval = fib(20);
    std:: cout << bigval << std::endl;
}
```

Overall, can increase performance for these pieces

- Compile code ends up being smaller

- Something runs onece during compiling and can be used as many times as you like during runtime

TMP was an accident; it was discovered, not invented

### Apllication of TMP

TMP isn't used that much, but it has some interesting applications

- Opimizing matrices/trees/other mathematical structures

- Policy-based design

- Game graphics

## Introduction to Algorithms

<font size=6 color=orange><u>***Solving problems with generics!***</u></font>

## Functions and Lambdas

A successfully templated function

```cpp
template <typename InputIt, typename DataType>
int count_occurrences(InputIt begin, InputIt end, DataType target) {
    int count = 0;
    for (auto iter = begin; iter != end; ++iter) {
        if (*iter == target) count++;
    }
    return count;
}

std::string str = "kkkkk";
std::cout << count_occurrences(str.begin(), str.end(), 'k') << std::endl;
```

This code will work for any containers with any types, for a single specific target

## Predicate Functions

Any function that returns a boolean value is a predicate

- `isVowel()` is an example of a predicate, but there are tons of others we might want

- A predicate can have any amount of parameters

```cpp
//Unary
bool isLowercaseA(char c) {
    return c == 'a';
}

bool isVowel(char c) {
    std::string vowels = "aeiou";
    return vowels.find(c) != std::string::npos;
}

//Binary
bool isMoreThan(int num, int limit) {
    return num > limit;
}

bool isDivisbleBy(int a, int b) {
    return (a % b == 0);
}
```

Let's use that

```cpp
template <typename InputIt, typename UniPred>
int count_occurences(InputIt begin, InputIt end, Unipred pred) {
    int count = 0;
    for (auto iter = begin; iter != end; ++iter) {
        if (pred(*iter)) count++;
    }
    return count;
}

bool isVowel(char c) {
    std::string vowels = "aeiou";
    return vowels.find(c) != std::string::npos;
}

std::string str = "Xadia";
count_occurences(str.begin(), str.end(), isVowel);
```

### Function Pointers

`UniPred` is what's called a **function pointer**

- Function pointers can be treated just like other pointers

- They can be passed around like variables as parameters or in template functions

- They can be called like functions

### Poor Generalization

Unary predicates are pretty limited and don't generalize well

```cpp
bool isMoreThan(int num, int limit) {
    return num > limit;
}
```

## Lambdas

Lambdas are **inline**, anonymous functions that can know about functions declared in their same scope

```cpp
int limit = 5;
auto isMoreThan = [limit] (int n) { return n > limit;};
isMoreThan(6); //true
```

- Use a lambda when you need a short function or to access local variables in your function

- If you need more logic or overloading, use function pointers

### Aside: What the Functor 

A **functor** is any class that provides an implementation of operator().

- They can create **closures** of "customized" functions

- **Closure:** a single instantiation of a functor object

```cpp
class functor {
public:
    int operator() (int arg) const {
        return num + arg;
    }
private:
    int num; //capture clause
};

int num = 0;
auto lambda = [&num] (int arg) {num += arg; };

### Aside: Virtual Functions

```cpp
class Animal {
    void speak() {
        std::cout << "I'm an animal" << std::endl;
    }
}

class Dog : Animal {
    void speak() {
        std::cout << "I'm a dog" << std::endl;
    }
}

void func(Animal* animal) {
    animal->speak();
}

int main() {
    Animal* myAnimal = new Animal;
    Dog* myDog = new Dog;
    func(myAnimal);
    func(myDog);
}

//The function expects an Animal. so it will try to use the Animal speak function
```

If you have a function that can take in a pointer to the superclass, it won't know to use the subclass's function

The same issue happens if we create a superclass pointer to an existing subclass object

To fix this, we can mark the overridden function as **virtual** in the header

Virtual functions are functions in the superclass we expect to be overridden later on

```cpp
void func(Animal* animal) {
    animal->speak();
}

int main() {
    Animal* myAnimal = new Animal;
    Dog* myDog = new Dog;
    func(myAnimal);
    func(myDog);
}

//Now calling speak() will use the correct subclass version
```

## Algorithms

The **STL** implements an entire library of algorithms written by C++ developers

- To utilize, `#include <algorithm>` in your file

- All algorithms are **fully generic, templated** functions

With the algorithm library, we can

- check if a condition is true across any elements

- apply a function to all elements in a container

- search for specific elements or a range

- copy, remove, add elements from one container to another

All standard algorithms work on iterators

- Efficient searching, sorting, complex data structure operations, smart pointers, and more are all there for you to use

- Check out the documentation to get more information

# Operators, Special Member Functions

## Operators and Operator Overloading

How do oerators work with classes

- Just like declaring functions in a class, we can declare operator functionality

- When we use that operator with our new object, it performs a custom function or operation

- Just like in function overloading, if we give it the same name, it will override the operator's behavior

### Overload operators in two ways

**Member functions**

- Declare your overloaded operator within the scope of your class

- Allow you to use member variabes of `this->`

**Non-member functions**

- Declare the overloaded operator outside of any classes

- Define both left and right hand objects as parameters

### Non-member overloading

Non-member overloading is preferred by the STL

- It allows the LHS to be a non-class type (ex. comparing `double` to a `Fraction`)

- Allows us to overload operators with classes we don't own (ex. `vector` to a `StudentList`)

```cpp
bool operator< (const Student& lhs, const Student& rhs);
```

Certain operators, like `new` and `delete`, don't require a specific type

- Overloading this outside of a class is called **global overloading** and will affect everything

### `friend`

The `friend` keyword allows non-member functions or classes to access private information in another class

- To use, declare the name of the function or class as a friend within the target class's header

- If it's a class, you must say `friend class [name]`

### Rules and Philosophy

- Meaning should be **obvious** when you see it 

- Functionality should be **reasonably similar** to corresponding arithmetic operations

    - Don't define `+` to mean set subtraction

- When the meaning isn't obvious, give it a normal name instead

## Copy and copy assignment

Many times, you will want to create a copy that does more than just copies the member variables

- Deep copy: an object that is a complete, **independent** copy of the origin

In these cases, you'd want to override the default special member functions with your own implementation

Declare them in the header and write their implementation in the .cpp, like any function

## Default and delete

```cpp
class PasswordManager {
public:
    PasswordManager();
    PasswordManager(const PasswordManager& pm);
    ~PasswordManager();
    PasswordManager(const PasswordManager& rhs) = delete;
    PasswordManager& operator = (const PasswordManager& rhs) = delete;

private:
    // others
}
```

Setting a special member function to **delete** removes its functionality

Now copying isn't a possible operation

### Rule

If the default SMFs word, **don't define your own!**

We should only define new ones when the default ones generated by the compiler won't work

- This usually happens when we work with dynamically allocated memory, like pointers to things on the heap

If you have to define a **destructor, copy constructor** or **copy assignment operator, youshould define them all!**

- Needing one signifies you're handling certain resources manually

- We then should handle the creation, assignment, use, and destruction of those resources ourselves

#### Recap

- Default Constructor

    - Object created with no parameters, no member variables instantiated

- Copy Constructor

    - Object created as a copy of existing object(member variable-wise)

- Copy Assignment Operator

    - Existing object replaced as a copy of another existing object

- Destructor

    - Object destroyed when it is out of scope

## Move and move assignment

Lets say we had to copy our current StringTable into another, whose reference is given to use, and we have no use for our StringTable afterwards

The copy constructor will copy every value in the `values` map one by one very slowly

### Move operations

- Move constructors and move assignment operators will perform "memberwise moves"

- Defining a move assignment operator **prevents generation** of a move copy constructor, and vice versa

    - If the move assignment operator needs to be re-implemented, there'd likely be a problem with the move constructor

### Caveats

Move constructors and operators are only generated if:

- No copy operations are declared

- No move oeperations are declared

- No destructor is declared

Declaring any of these will get rid of the default C++ generated operations

```cpp
Widget(Widget&&) = default
Widget& operator = (Widget&&) = default

Widget(const Widget&) = delete;
Widget& operator = (const Widget&) = default
```

# Move Semantics, Type safety

## Move Semantics

```cpp
class HumanGenome {
private:
    std::vector<char> data'
public:
    HumanGenome(HumanGenome&& other) noexcept
    data(std::move(other.data)) {
        std::cout << "HumanGenome moved into stage." << std::endl;
    }
}
```

`noexcept` bascially says "hey I guarantee not to throw an exception"

`HumanGenome&& other` basically says "I'm gonna yank this thing's resource, I will treat it as an r-value"

### `std::move`

```cpp
class HumanGenome {
private:
    std::vector<char> data;
public:
    HumanGenome & operator = (HumanGenome&& other) noexcept {
        if (this != &other) {
            data = std::move(other.data)
            std::cout << "HumanGenome moved within stage." << std::endl;
        }
        return *this;
    }
}
```

`std::move` changes an l-value to an x-value. Whenever the original object is no longer needed you can use std::move to transfer as opposed to copy

#### x-value

You can plunder me, **move** anything I'm holding and use it elsewhere (since I'm going to be destroyed soon away)

### Back to `std::move`

- You should use this when you're assigning some l-value that is no longer needed where it is previously stored

- Generally, we want to avoid using `std::move()` in application code. Use it in class definitions, like constructors and operators

    - The compiler can do much of the optimizations without you needing to do `std::move()` if you define the move constructor and move assignment operator

### Summary

- If your class has <font color=blue>copy constructor</font> and <font color=blue>copy assignment</font> defined, you should also define a <font color=orange>move constructor</font> and <font color=orange>move assignment</font>

- Definee these by overloading your constructor and assignment to be defined for `Type&& other` as well as `Type& other`

- Use `std::move` to force the use of other types' move assignments and constructors

- All `std::move(x)` does is cast `x` as an x-value

- Be wary of `std::move(x)` in main function code

**At this point You know about:**

1. **Default constructor:** Initializes an object to a default state

2. **Copy constructor:** Creates a new object by copying an existing object

3. **Move constructor:** Creates a new object by moving the resources of an existing object

4. **Copy Assignment Operator:** Assigns the contents of one object another object

5. **Move Assignment Operator:** Moves the resources of one object to another object

6. **Destructor:** Frees any dynamically allocated resources owned by an object when it is destroyed

### Philosophy about SMFs

1. Rule of Zero

2. Rule of Three

3. Rule of Five

#### Rule of Zero

If your class relies on objects/classes that already have these SMFs implemented, then there's no need to reimplement this logic

```cpp
class a_string_with_an_id() {
    public:
        // getter and setter methods for our private variables
    private:
        int id;
        std::string str;
}
a_string_with_an_id object;
```

#### Rule of Three

If you need a custom destructor, then you also probably <u>***need***</u> to define a copy constructor and a copy assignment operator for your class

#### Rule of Five

If you define a copy constructor or copy assignment operator, then you <u>***should***</u> define a move constructor and a move assignment operator as well

## Type safety

<font color=orange>**Type Safety:**</font> The extent to which a language prevents typing errors.

```cpp
void removeOddsFromEnd(vector<int>& vec){
    while(vec.back() % 2 == 1) {
        vec.pop_back();
    }
}
```
If `vec` is `{}` / an empty vector, when calling back on an empty container causes **undefined behavior**

**Undefined behavior:** Function could crash, could give us garbage, could accidentally give us some actual value

<font color=orange>**Key idea:**</font> It is the **programmers job** to enforce the precondition that `vec` be non-empty, otherwise we get undefined behavior

Deterministic behavior is great, but there may or may not be a "last element" in `vec` How can `vec.back()` warn us of that when we call it?

```cpp
std::pair<bool, valueType&> vector<valueType>::back(){
    if(empty()) {
        return {false, valueType()};
    }
    return {true, *(begin() + size() - 1)};
}
```

- `valueType` may not have a default constructor 

- Even if it does, calling constructors is **expensive**

## `std::optional`

- `std::optional` is a template class which will either contain a value of type `T` or contain nothing(expressed as `nullopt`)

    - `.value()` method: returns the contained value or throws `bad_optional_access` error

    - `.value_or(valueType val)` returns the contained value or default value, parameter `val`

    - `.has_value()` returns true if contained value exists, false otherwise

```cpp
void main() {
    std::optional<int> num1 = {}; // num1 does not have a value
    num1 = 1; // now it does
    num1 = std::nullopt; // now it doesn't any more
}
```

An `optional` take on `readVector`

```cpp
void removeOddsFromEnd(vector<int>& vec) {
    auto isOdd = [] (optional<int> num) {
        if (num)
            return num % 2 == 1;
        else
            return std::nullopt;
        // return num ? (num % 2 == 1) : {}
    };
    while(vec.back().and_then(isOdd)) {
        vec.pop_back();
    }
}
```

Disclaimer: `std::vector::back()` doesn't actually return an optional (and probably never will)