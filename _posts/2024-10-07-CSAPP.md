---
title: CSAPP
date: 2024-10-07 14:38:13
tags: C
categories: Computer Science
mathjax: true
---
# Bits, Bytes, and Integers

Everything is bits

- By encoding/interpreting sets of bits in various ways

- Electronic Implementation

Represent all the numbers by bits in computer

## Byte Values

- Byte: 8 bits

Hex | Decimal | Binary
--- | --- | ---
0 | 0 | 0000
1 | 1 | 0001
2 | 2 | 0010
3 | 3 | 0011
4 | 4 | 0100
5 | 5 | 0101
6 | 6 | 0110
7 | 7 | 0111
8 | 8 | 1000
9 | 9 | 1001
A | 10 | 1010
B | 11 | 1011
C | 12 | 1100
D | 13 | 1101
E | 14 | 1110
F | 15 | 1111

## Data Representation

C Data Types \ Bytes | 32-bit | 64-bit | x86-64
--- | --- | --- | ---
char | 1 | 1 | 1
short | 2 | 2 | 2
int | 4 | 4 | 4
long | 4 | 8 | 8
float | 4 | 4 | 4
double | 8 | 8 | 8
long double | - | - | 10/16
pointer | 4 | 8 | 8

Any address is defined by the word size of the machine e.g. 32-bit or 64-bit

## Boolean Algebra

- `&` AND : A & B = 1 when both A and B are 1 (intersection)

- `|` OR : A | B = 1 when either A or B is 1 (union)

- `~` NOT : ~A = 1 when A is 0 (Complement)

- `^` XOR : A ^ B = 1 when A and B are different (Symmetric Difference)

## Contrast

`&&`, `||`, `!` (Don't mix up with `&`, `|`, `~`)

- View 0 as "False"

- Any non-zero value is "True"

- Always return 0 or 1 (True or False)

- Early termination

## Shift Operation

- `<<` Left Shift : A << B = A * 2^B

    - Throw away bits on left

    - Fill with 0s on right

- `>>` Right Shift : A >> B = A / 2^B

    - Throw away bits on right

    - Arithmetic Shift : Keep the sign bit the same

    - Logical Shift : Fill with 0s on left

## Numeric Ranges

$w$ is the word size of the machine

- Unsigned Values

    - $0$ to $2^w - 1$

- Signed Values

    - $-2^{w-1}$ to $2^{w-1} - 1$

## Encoding Integers

- Unsigned

    $$B2U_w(x) = \sum_{i=0}^{w-1} x_i \cdot 2^i$$

- Two's Complement

    $$B2T_w(x) = -x_{w-1} \cdot 2^{w-1} + \sum_{i=0}^{w-2} x_i \cdot 2^i$$

    - $x_{w-1}$ is the sign bit

    - $|TMin_w| = |TMax_w| + 1$

## Sign Extension

Make k copies of the sign bit to the left

## Addition & Multiplication

- Operands $w$ bits

- If True Sum: $w+1$ bits Otherwise $w$ bits

- Discard Carry $w$ bits

## Shift Operation

- Multiply

    - Both signed and unsigned $u << k$ gives $u * 2^k$

- Divide

    - Signed: $u >> k$ gives (arithmetic shift) 

        - $\lfloor u / 2^k \rfloor$ if $u \geq 0$

        - $\lceil u / 2^k \rceil$ if $u < 0$


    - Unsigned : $u >> k$ gives $\lfloor u / 2^k \rfloor$ (logical shift)

## Representation in Memory

Memory is a big array of bytes

Addresses Specify the Byte Locations

## Byte Ordering

- Big Endian: Least significant byte has the highest address

- Little Endian: Least significant byte has the lowest address

## Representing Strings

Represent string by a sequence of bytes encoded in ASCII

# Floating Point

## Fractional Binary Numbers

Represents rational numbers: $$\sum_{k=-j}^{i} b_k \times 2^k$$

## IEEE Floating Point

Numerical Form: $$V = (-1)^s * M * 2^E$$

- $s$ is the sign bit (MSB)

- $M$ is the significand in range $[1.0, 2.0)$ (frac field encodes M)

- $E$ is the exponent weights value by power of 2 (exp field encodes E)

|  | 32-bit | 64-bit
--- | --- | ---
s | 1 | 1
E | 8 | 11
M | 23 | 52

## Normalized Values

Exponent coded as a biased value: $$E = Exp - Bias$$

- $Exp$: unsigned value of exp field

- $Bias = 2^{k-1} - 1$, where $k$ is number of exponent bits

## Denormalized Values

- Condition: $Exp = 0$ (exp = 000...0)

- Exponent value: $E = 1 - Bias$

- Significand value: $M = 0.xxx...x$ (xxx...x: bits of frac)

## Special Values

exp | frac | value
--- | --- | ---
111...1 | 000...0 | $\infty$
111...1 | !000...0 | NaN

## Floating Point Operations

Basic idea:

1. compute exact result

2. Make it fit into desired precision

## Rounding

- Towards zero

- Round down ($-\infty$)

- Round up ($+\infty$)

- Nearest even (default)

### Rounding Binary Numbers

- "Even" when least significant bit is 0

- "Half way" when bits to right of rounding position = 100...

## Floating Point Multiplication

$$(-1)^{s1} * M1 * 2^{E1} * (-1)^{s2} * M2 * 2^{E2} = (-1)^{s} * M * 2^E$$

- Sign s: s1 ^ s2

- Significand M: M1 * M2

- Exponent E: E1 + E2

- Fixing

    - If M $\geq$ 2, shift M right and increment E

    - If E out of range, overflow

    - Round M to fit frac precision

## Floating Point Addition

$$(-1)^s1 * M1 * 2^{E1} + (-1)^s2 * M2 * 2^{E2} = (-1)^s * M * 2^E$$

- Sign s: s1 & s2

- Exponent E: max(E1, E2)

- Significand M: M1 + M2

- Fixing

    - If M $\geq$ 2, shift M right and increment E

    - If M < 1, shift M left k positions and decrement E by k

    - Overflow if E out of range

    - Round M to fit frac precision

## Floating Point in C

- `float` : single precision (32-bit)

- `double` : double precision (64-bit)

